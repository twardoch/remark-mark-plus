{"version":3,"file":"micromark-syntax.js","names":["_micromarkUtilSymbol","require","_micromarkUtilCharacter","MARKER_CODE","codes","equalsTo","SEQUENCE_SIZE","types","exports","mark","markSequence","markText","markSyntax","text","tokenize","tokenizeMark","partial","effects","ok","nok","tokenizeClosingSequence","size","startSequence","code","enter","_temporary","consume","insideSequence","exit","start","insideOpeningSequence","checkAfterOpening","markdownSpace","coreTokenTypes","chunkString","contentType","constants","contentTypeString","contentText","eof","markdownLineEnding","attempt","afterClosingSequenceSuccess","afterClosingSequenceFail_reEnterChunk"],"sources":["../../src/lib/micromark-syntax.js"],"sourcesContent":["/**\n * @fileoverview\n *   Micromark syntax extension to support GFM-like mark (`==highlighted==`).\n */\n\n// src/lib/micromark-syntax.js\nimport {codes, constants, types as coreTokenTypes} from 'micromark-util-symbol'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n\nconst MARKER_CODE = codes.equalsTo\nconst SEQUENCE_SIZE = 2\n\n/**\n * Token types for the mark syntax.\n * @enum {string}\n */\nexport const types = {\n  mark: 'mark', // The main wrapping token for a mark node `==text==`\n  markSequence: 'markSequence', // Token for the `==` sequence\n  markText: 'markText', // Token for the text content within marks\n}\n\n/**\n * Micromark extension for GFM-like mark syntax.\n *\n * @returns {import('micromark-util-types').Extension}\n *   The Micromark extension.\n */\nexport function markSyntax () {\n  return {\n    text: {[MARKER_CODE]: {tokenize: tokenizeMark, partial: true}},\n  }\n}\n\n/** @type {import('micromark-util-types').Tokenizer} */\nfunction tokenizeMark (effects, ok, nok) {\n  // This is the tokenizer for the potential closing sequence\n  const tokenizeClosingSequence = (effects, ok, nok) => {\n    let size = 0\n\n    return startSequence\n\n    function startSequence(code) {\n      // We are here because contentText saw an '='.\n      // That '=' is the 'code' passed to this function.\n      if (code !== MARKER_CODE) return nok(code) // Should not happen if called correctly\n      effects.enter(types.markSequence, {_temporary: true}) // Mark as temporary\n      effects.consume(code)\n      size++\n      return insideSequence\n    }\n\n    function insideSequence(code) {\n      if (size < SEQUENCE_SIZE && code === MARKER_CODE) {\n        effects.consume(code)\n        size++\n        return insideSequence // Stay in this state if we're building up the sequence\n      }\n\n      if (size === SEQUENCE_SIZE) {\n        effects.exit(types.markSequence)\n        // The `ok` callback (afterClosingSequenceSuccess) will handle exiting other tokens\n        return ok // `attempt` will call `afterClosingSequenceSuccess` with the char *after* `==`\n      }\n\n      // Not a full sequence (e.g., \"=b\" or just \"=\" at EOF/space)\n      // The `markSequence` was temporary, so `effects.attempt` will discard it.\n      return nok // `attempt` will call `afterClosingSequenceFail` with the original char that started the attempt\n    }\n  }\n\n\n  return start\n\n  /** @type {import('micromark-util-types').State} */\n  function start (code) {\n    // `code` is the first suspected marker character.\n    // Tokenizer is invoked when `MARKER_CODE` is seen.\n    effects.enter(types.markSequence)\n    effects.consume(code) // Consume the first '='\n    return insideOpeningSequence\n  }\n\n  /** @type {import('micromark-util-types').State} */\n  function insideOpeningSequence (code) {\n    // `code` is the character *after* the first consumed '='.\n    if (code === MARKER_CODE) { // This is the second '='\n      effects.consume(code)\n      effects.exit(types.markSequence) // Successfully consumed \"==\"\n      return checkAfterOpening // Next state will get char after \"==\"\n    }\n    // The character after the first \"=\" was not another \"=\".\n    // So, the first \"=\" was not part of our \"==\" sequence.\n    effects.exit(types.markSequence) // Exit the sequence for the single initial \"=\".\n    return nok(code) // Let other tokenizers handle this `code`. Micromark will backtrack.\n  }\n\n  /** @type {import('micromark-util-types').State} */\n  function checkAfterOpening (code) {\n    // `code` here is the character *immediately after* the opening \"==\".\n    // Disallow \"===\", \"==\\s\", or \"==\" at EOF.\n    if (code === MARKER_CODE || markdownSpace(code) || code === null) {\n      return nok(code)\n    }\n    // Valid opening, proceed to content\n    effects.enter(types.mark) // Enter the main \"mark\" token\n    effects.enter(types.markText) // Enter the \"markText\" token for content\n    // Enter a chunkString token for the actual text data\n    effects.enter(coreTokenTypes.chunkString, {contentType: constants.contentTypeString})\n    return contentText(code) // Start consuming content with the current valid character\n  }\n\n  /** @type {import('micromark-util-types').State} */\n  function contentText (code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      // Unterminated or newline breaks mark\n      effects.exit(coreTokenTypes.chunkString) // Exit chunkString before markText\n      effects.exit(types.markText)\n      effects.exit(types.mark)\n      return nok(code)\n    }\n\n    if (code === MARKER_CODE) {\n      // Potential closing sequence. Exit current chunkString first.\n      effects.exit(coreTokenTypes.chunkString);\n\n      return effects.attempt(\n        {tokenize: tokenizeClosingSequence, partial: true},\n        afterClosingSequenceSuccess, // On success, chunkString is already exited.\n        afterClosingSequenceFail_reEnterChunk // On failure, must re-enter chunkString.\n      )(code);\n    }\n\n    effects.consume(code); // This is for the currently open chunkString\n    return contentText;\n  }\n\n  function afterClosingSequenceSuccess(code) { // chunkString was exited by contentText before attempt\n    // effects.exit(coreTokenTypes.chunkString); // No longer needed here\n    effects.exit(types.markText);\n    effects.exit(types.mark);\n    return ok(code); // This `ok` is the main `ok` from `tokenizeMark`\n  }\n\n  function afterClosingSequenceFail_reEnterChunk(code) { // chunkString was exited by contentText before attempt\n    // Attempt failed. The original MARKER_CODE (which is `code` here) should be content.\n    // Re-enter chunkString to capture it.\n    effects.enter(coreTokenTypes.chunkString, {contentType: constants.contentTypeString}); // Re-enter chunkString\n    effects.consume(code); // Consume the MARKER_CODE ('=') as regular content\n    // chunkString is now open again.\n    return contentText;    // Go back to contentText for the next char.\n  }\n}\n"],"mappings":";;;;;;;AAMA,IAAAA,oBAAA,GAAAC,OAAA;AACA,IAAAC,uBAAA,GAAAD,OAAA;AAPA;AACA;AACA;AACA;;AAEA;;AAIA,MAAME,WAAW,GAAGC,0BAAK,CAACC,QAAQ;AAClC,MAAMC,aAAa,GAAG,CAAC;;AAEvB;AACA;AACA;AACA;AACO,MAAMC,KAAK,GAAAC,OAAA,CAAAD,KAAA,GAAG;EACnBE,IAAI,EAAE,MAAM;EAAE;EACdC,YAAY,EAAE,cAAc;EAAE;EAC9BC,QAAQ,EAAE,UAAU,CAAE;AACxB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,UAAUA,CAAA,EAAI;EAC5B,OAAO;IACLC,IAAI,EAAE;MAAC,CAACV,WAAW,GAAG;QAACW,QAAQ,EAAEC,YAAY;QAAEC,OAAO,EAAE;MAAI;IAAC;EAC/D,CAAC;AACH;;AAEA;AACA,SAASD,YAAYA,CAAEE,OAAO,EAAEC,EAAE,EAAEC,GAAG,EAAE;EACvC;EACA,MAAMC,uBAAuB,GAAGA,CAACH,OAAO,EAAEC,EAAE,EAAEC,GAAG,KAAK;IACpD,IAAIE,IAAI,GAAG,CAAC;IAEZ,OAAOC,aAAa;IAEpB,SAASA,aAAaA,CAACC,IAAI,EAAE;MAC3B;MACA;MACA,IAAIA,IAAI,KAAKpB,WAAW,EAAE,OAAOgB,GAAG,CAACI,IAAI,CAAC,EAAC;MAC3CN,OAAO,CAACO,KAAK,CAACjB,KAAK,CAACG,YAAY,EAAE;QAACe,UAAU,EAAE;MAAI,CAAC,CAAC,EAAC;MACtDR,OAAO,CAACS,OAAO,CAACH,IAAI,CAAC;MACrBF,IAAI,EAAE;MACN,OAAOM,cAAc;IACvB;IAEA,SAASA,cAAcA,CAACJ,IAAI,EAAE;MAC5B,IAAIF,IAAI,GAAGf,aAAa,IAAIiB,IAAI,KAAKpB,WAAW,EAAE;QAChDc,OAAO,CAACS,OAAO,CAACH,IAAI,CAAC;QACrBF,IAAI,EAAE;QACN,OAAOM,cAAc,EAAC;MACxB;MAEA,IAAIN,IAAI,KAAKf,aAAa,EAAE;QAC1BW,OAAO,CAACW,IAAI,CAACrB,KAAK,CAACG,YAAY,CAAC;QAChC;QACA,OAAOQ,EAAE,EAAC;MACZ;;MAEA;MACA;MACA,OAAOC,GAAG,EAAC;IACb;EACF,CAAC;EAGD,OAAOU,KAAK;;EAEZ;EACA,SAASA,KAAKA,CAAEN,IAAI,EAAE;IACpB;IACA;IACAN,OAAO,CAACO,KAAK,CAACjB,KAAK,CAACG,YAAY,CAAC;IACjCO,OAAO,CAACS,OAAO,CAACH,IAAI,CAAC,EAAC;IACtB,OAAOO,qBAAqB;EAC9B;;EAEA;EACA,SAASA,qBAAqBA,CAAEP,IAAI,EAAE;IACpC;IACA,IAAIA,IAAI,KAAKpB,WAAW,EAAE;MAAE;MAC1Bc,OAAO,CAACS,OAAO,CAACH,IAAI,CAAC;MACrBN,OAAO,CAACW,IAAI,CAACrB,KAAK,CAACG,YAAY,CAAC,EAAC;MACjC,OAAOqB,iBAAiB,EAAC;IAC3B;IACA;IACA;IACAd,OAAO,CAACW,IAAI,CAACrB,KAAK,CAACG,YAAY,CAAC,EAAC;IACjC,OAAOS,GAAG,CAACI,IAAI,CAAC,EAAC;EACnB;;EAEA;EACA,SAASQ,iBAAiBA,CAAER,IAAI,EAAE;IAChC;IACA;IACA,IAAIA,IAAI,KAAKpB,WAAW,IAAI,IAAA6B,qCAAa,EAACT,IAAI,CAAC,IAAIA,IAAI,KAAK,IAAI,EAAE;MAChE,OAAOJ,GAAG,CAACI,IAAI,CAAC;IAClB;IACA;IACAN,OAAO,CAACO,KAAK,CAACjB,KAAK,CAACE,IAAI,CAAC,EAAC;IAC1BQ,OAAO,CAACO,KAAK,CAACjB,KAAK,CAACI,QAAQ,CAAC,EAAC;IAC9B;IACAM,OAAO,CAACO,KAAK,CAACS,0BAAc,CAACC,WAAW,EAAE;MAACC,WAAW,EAAEC,8BAAS,CAACC;IAAiB,CAAC,CAAC;IACrF,OAAOC,WAAW,CAACf,IAAI,CAAC,EAAC;EAC3B;;EAEA;EACA,SAASe,WAAWA,CAAEf,IAAI,EAAE;IAC1B,IAAIA,IAAI,KAAKnB,0BAAK,CAACmC,GAAG,IAAI,IAAAC,0CAAkB,EAACjB,IAAI,CAAC,EAAE;MAClD;MACAN,OAAO,CAACW,IAAI,CAACK,0BAAc,CAACC,WAAW,CAAC,EAAC;MACzCjB,OAAO,CAACW,IAAI,CAACrB,KAAK,CAACI,QAAQ,CAAC;MAC5BM,OAAO,CAACW,IAAI,CAACrB,KAAK,CAACE,IAAI,CAAC;MACxB,OAAOU,GAAG,CAACI,IAAI,CAAC;IAClB;IAEA,IAAIA,IAAI,KAAKpB,WAAW,EAAE;MACxB;MACAc,OAAO,CAACW,IAAI,CAACK,0BAAc,CAACC,WAAW,CAAC;MAExC,OAAOjB,OAAO,CAACwB,OAAO,CACpB;QAAC3B,QAAQ,EAAEM,uBAAuB;QAAEJ,OAAO,EAAE;MAAI,CAAC,EAClD0B,2BAA2B;MAAE;MAC7BC,qCAAqC,CAAC;MACxC,CAAC,CAACpB,IAAI,CAAC;IACT;IAEAN,OAAO,CAACS,OAAO,CAACH,IAAI,CAAC,CAAC,CAAC;IACvB,OAAOe,WAAW;EACpB;EAEA,SAASI,2BAA2BA,CAACnB,IAAI,EAAE;IAAE;IAC3C;IACAN,OAAO,CAACW,IAAI,CAACrB,KAAK,CAACI,QAAQ,CAAC;IAC5BM,OAAO,CAACW,IAAI,CAACrB,KAAK,CAACE,IAAI,CAAC;IACxB,OAAOS,EAAE,CAACK,IAAI,CAAC,CAAC,CAAC;EACnB;EAEA,SAASoB,qCAAqCA,CAACpB,IAAI,EAAE;IAAE;IACrD;IACA;IACAN,OAAO,CAACO,KAAK,CAACS,0BAAc,CAACC,WAAW,EAAE;MAACC,WAAW,EAAEC,8BAAS,CAACC;IAAiB,CAAC,CAAC,CAAC,CAAC;IACvFpB,OAAO,CAACS,OAAO,CAACH,IAAI,CAAC,CAAC,CAAC;IACvB;IACA,OAAOe,WAAW,CAAC,CAAI;EACzB;AACF","ignoreList":[]}