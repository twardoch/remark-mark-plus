{"version":3,"file":"micromark-syntax.js","names":["_micromarkUtilSymbol","require","_micromarkUtilCharacter","MARKER_CODE","codes","equalsTo","SEQUENCE_SIZE","types","exports","mark","markSequence","markText","markSyntax","text","tokenize","tokenizeMark","partial","effects","ok","nok","closeSeqSize","start","code","enter","consume","insideOpeningSequence","exit","checkAfterOpening","markdownSpace","contentText","eof","markdownLineEnding","closingSequence"],"sources":["../../src/lib/micromark-syntax.js"],"sourcesContent":["/**\n * @fileoverview\n *   Micromark syntax extension to support GFM-like mark (`==highlighted==`).\n */\n\n// src/lib/micromark-syntax.js\nimport {codes} from 'micromark-util-symbol'\n// Removed: import {types as coreTypes} from 'micromark-util-symbol/types.js'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n\nconst MARKER_CODE = codes.equalsTo\nconst SEQUENCE_SIZE = 2\n\n/**\n * Token types for the mark syntax.\n * @enum {string}\n */\nexport const types = {\n  mark: 'mark', // The main wrapping token for a mark node `==text==`\n  markSequence: 'markSequence', // Token for the `==` sequence\n  markText: 'markText', // Token for the text content within marks\n}\n\n/**\n * Micromark extension for GFM-like mark syntax.\n *\n * @returns {import('micromark-util-types').Extension}\n *   The Micromark extension.\n */\nexport function markSyntax () {\n  return {\n    text: {[MARKER_CODE]: {tokenize: tokenizeMark, partial: true}},\n  }\n}\n\n/** @type {import('micromark-util-types').Tokenizer} */\nfunction tokenizeMark (effects, ok, nok) {\n  // const self = this // Removed as 'this' is used directly by state functions\n  // let openSeqSize = 0 // Replaced by direct state transitions\n  let closeSeqSize = 0\n  // Removed: let textStartPoint\n\n  return start\n\n  /** @type {import('micromark-util-types').State} */\n  function start (code) {\n    // `code` is the first suspected marker character.\n    // Tokenizer is invoked when `MARKER_CODE` is seen.\n    effects.enter(types.markSequence)\n    effects.consume(code) // Consume the first '='\n    return insideOpeningSequence\n  }\n\n  /** @type {import('micromark-util-types').State} */\n  function insideOpeningSequence (code) {\n    // `code` is the character *after* the first consumed '='.\n    if (code === MARKER_CODE) { // This is the second '='\n      effects.consume(code)\n      effects.exit(types.markSequence) // Successfully consumed \"==\"\n      return checkAfterOpening // Next state will get char after \"==\"\n    }\n    // The character after the first \"=\" was not another \"=\".\n    // So, the first \"=\" was not part of our \"==\" sequence.\n    effects.exit(types.markSequence) // Exit the sequence for the single initial \"=\".\n    return nok(code) // Let other tokenizers handle this `code`. Micromark will backtrack.\n  }\n\n  /** @type {import('micromark-util-types').State} */\n  function checkAfterOpening (code) {\n    // `code` here is the character *immediately after* the opening \"==\".\n    // Disallow \"===\", \"==\\s\", or \"==\" at EOF.\n    if (code === MARKER_CODE || markdownSpace(code) || code === null) {\n      return nok(code)\n    }\n    // Valid opening, proceed to content\n    effects.enter(types.mark) // Enter the main \"mark\" token\n    effects.enter(types.markText) // Enter the \"markText\" token for content\n    return contentText(code) // Start consuming content with the current valid character\n  }\n\n  /** @type {import('micromark-util-types').State} */\n  function contentText (code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      // Unterminated or newline breaks mark\n      effects.exit(types.markText)\n      effects.exit(types.mark)\n      return nok(code)\n    }\n\n    if (code === MARKER_CODE) {\n      // Potential closing sequence\n      effects.exit(types.markText)\n      effects.enter(types.markSequence) // Potential closing sequence\n      closeSeqSize = 0\n      return closingSequence(code)\n    }\n\n    effects.consume(code)\n    return contentText\n  }\n\n  /** @type {import('micromark-util-types').State} */\n  function closingSequence (code) {\n    if (code === MARKER_CODE && closeSeqSize < SEQUENCE_SIZE) {\n      effects.consume(code)\n      closeSeqSize++\n      return closingSequence\n    }\n\n    if (closeSeqSize === SEQUENCE_SIZE) {\n      // Valid \"==\" closing sequence.\n      // Check if char before this closing sequence (last char of markText) was whitespace.\n      // This simplified version doesn't robustly check \"no space before closing marker\".\n      // It also doesn't correctly handle \"==a =b==\" (single '=' consumed by closingSequence\n      // and fail).\n\n      // Example of a robust check (omitted for now for simplicity):\n      // const precedingChar = events[events.length - 1].previous /* ... complex access ... */\n      // if (markdownSpace(precedingChar)) return nok(code)\n\n      effects.exit(types.markSequence) // Exit closing \"==\"\n      effects.exit(types.mark) // Exit main \"mark\"\n      return ok(code)\n    }\n\n    // Not a \"==\". This means the first \"=\" was part of text.\n    // We need to \"re-tokenize\" that first \"=\" as text.\n    // Simplest is `nok` here, assuming `partial:true` lets it be re-parsed as text.\n    // This means \"==a=b==\" would fail to parse the outer mark correctly.\n    return nok(code)\n  }\n}\n"],"mappings":"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","ignoreList":[]}